<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>PARTICLE_ROVER_ULTIMATE | 粒子漫游者终极版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root { --neon: #00f2ff; --pink: #ff00ff; --panel-bg: rgba(0, 5, 15, 0.9); }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; overflow: hidden; font-family: 'Consolas', 'Courier New', monospace; color: white; }
        
        #render-target { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* HUD & Panels */
        .side-panel {
            position: absolute; top: 0; height: 100%; width: 280px;
            background: var(--panel-bg); backdrop-filter: blur(15px);
            z-index: 100; border: 1px solid rgba(0, 242, 255, 0.2);
            padding: 25px; box-sizing: border-box; overflow-y: auto;
        }
        .left-p { left: 0; border-left: none; box-shadow: 5px 0 15px rgba(0,0,0,0.5); }
        .right-p { right: 0; border-right: none; box-shadow: -5px 0 15px rgba(0,0,0,0.5); }

        h3 { color: var(--neon); font-size: 14px; border-bottom: 1px solid var(--neon); padding-bottom: 8px; margin: 20px 0 15px 0; text-transform: uppercase; letter-spacing: 2px; }
        .group { margin-bottom: 18px; }
        label { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 6px; color: #aaa; }
        
        input[type="range"], select, input[type="color"] {
            width: 100%; background: #0a0a0a; border: 1px solid #333; color: white; padding: 6px; outline: none; cursor: pointer;
        }

        .btn {
            width: 100%; padding: 12px; background: transparent; border: 1px solid var(--neon);
            color: var(--neon); cursor: pointer; margin-top: 10px; transition: 0.2s;
            font-size: 11px; font-weight: bold; text-transform: uppercase;
        }
        .btn:hover { background: var(--neon); color: #000; box-shadow: 0 0 15px var(--neon); }

        #upload-zone {
            border: 2px dashed rgba(0, 242, 255, 0.3); padding: 20px; text-align: center;
            font-size: 11px; cursor: pointer; transition: 0.3s;
        }
        #upload-zone:hover { border-color: var(--neon); background: rgba(0, 242, 255, 0.1); }

        .hud-top { position: absolute; top: 15px; left: 50%; transform: translateX(-50%); z-index: 50; color: var(--neon); font-size: 10px; letter-spacing: 8px; text-shadow: 0 0 5px var(--neon); }
    </style>
</head>
<body>

    <div class="hud-top">SYSTEM STATUS: LINKED // NEURAL_INTERFACE</div>
    <div id="render-target"></div>

    <div class="side-panel left-p">
        <h3>粒子形变模式</h3>
        <div class="group">
            <label>当前几何体</label>
            <select id="shapeMode">
                <option value="cloud">云朵 (Sphere)</option>
                <option value="box">立方阵 (Cube)</option>
                <option value="wave">波浪线 (Wave)</option>
                <option value="ring">环形 (Torus)</option>
                <option value="vortex">涡流 (Vortex)</option>
                <option value="image">图像映射 (Image)</option>
            </select>
        </div>

        <div class="group">
            <label>上传参考图</label>
            <div id="upload-zone" onclick="document.getElementById('imgInp').click()">
                点击上传图片进行粒子重组
            </div>
            <input type="file" id="imgInp" accept="image/*" style="display:none">
        </div>

        <h3>粒子属性</h3>
        <div class="group">
            <label>粒子直径 <span id="val-size">0.03</span></label>
            <input type="range" id="pSize" min="0.005" max="0.2" step="0.005" value="0.03">
        </div>
        <div class="group">
            <label>系统扰动 <span id="val-noise">0.5</span></label>
            <input type="range" id="pNoise" min="0" max="10" step="0.1" value="0.5">
        </div>
        <div class="group">
            <label>粒子总数 (需刷新)</label>
            <select id="pCount">
                <option value="5000">5,000 (流畅)</option>
                <option value="15000" selected>15,000 (标准)</option>
                <option value="40000">40,000 (高表现)</option>
            </select>
        </div>
    </div>

    <div class="side-panel right-p">
        <h3>动力学控制</h3>
        <div class="group">
            <label>演化步频 <span id="val-speed">1.0</span></label>
            <input type="range" id="pSpeed" min="0" max="5" step="0.1" value="1.0">
        </div>
        <div class="group">
            <label>鼠标平衡影响 <span id="val-mforce">5</span></label>
            <input type="range" id="mForce" min="0" max="30" step="1" value="5">
        </div>

        <h3>色彩设置</h3>
        <div class="group">
            <label>核心主色</label>
            <input type="color" id="pColor" value="#00f2ff">
        </div>
        <div class="group">
            <label>背景基色</label>
            <input type="color" id="bgColor" value="#000308">
        </div>

        <h3>终端输出</h3>
        <button class="btn" onclick="saveFrame('png')">捕获高清 PNG</button>
        <button class="btn" onclick="saveFrame('jpg')">捕获 JPG</button>

        <div style="margin-top: 40px; font-size: 10px; opacity: 0.4; line-height: 1.6;">
            TERMINAL_OPS:<br>
            - DRAG: 3D Rotate<br>
            - WHEEL: Zoom In/Out<br>
            - MOVE: Particle Distortion
        </div>
    </div>

<script>
    /**
     * 粒子漫游者 终极引擎架构
     */
    let scene, camera, renderer, points;
    let particlesData = [];
    let mouse = new THREE.Vector2(-999, -999);
    let targetPositions = [];
    let currentCount = 15000;

    const shapeMode = document.getElementById('shapeMode');
    const imgInp = document.getElementById('imgInp');

    function init() {
        // 场景基础
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            preserveDrawingBuffer: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(document.getElementById('bgColor').value);
        document.getElementById('render-target').appendChild(renderer.domElement);

        createSystem();
        bindEvents();
        animate();
    }

    function createSystem() {
        if (points) {
            scene.remove(points);
            points.geometry.dispose();
            points.material.dispose();
        }

        currentCount = parseInt(document.getElementById('pCount').value);
        const geo = new THREE.BufferGeometry();
        const positions = new Float32Array(currentCount * 3);
        targetPositions = new Float32Array(currentCount * 3);

        // 初始随机分布
        for (let i = 0; i < currentCount * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 15;
            targetPositions[i] = positions[i];
        }

        geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const mat = new THREE.PointsMaterial({
            color: document.getElementById('pColor').value,
            size: parseFloat(document.getElementById('pSize').value),
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        points = new THREE.Points(geo, mat);
        scene.add(points);
        
        updateShapeTarget(shapeMode.value);
    }

    function updateShapeTarget(type) {
        const count = currentCount;
        for (let i = 0; i < count; i++) {
            const i3 = i * 3;
            let x, y, z;

            if (type === 'cloud') {
                const r = 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
            } else if (type === 'box') {
                x = (Math.random() - 0.5) * 5;
                y = (Math.random() - 0.5) * 5;
                z = (Math.random() - 0.5) * 5;
            } else if (type === 'wave') {
                x = (i / count) * 12 - 6;
                y = Math.sin(x * 1.5) * 1.5;
                z = Math.cos(x * 1.5) * 1.5;
            } else if (type === 'ring') {
                const rOuter = 4, rInner = 1;
                const angle = (i / count) * Math.PI * 2;
                x = Math.cos(angle) * (rOuter + Math.random() * rInner);
                y = Math.sin(angle) * (rOuter + Math.random() * rInner);
                z = (Math.random() - 0.5) * 1.5;
            } else if (type === 'vortex') {
                const radius = (i / count) * 5;
                const angle = 0.5 * i;
                x = radius * Math.cos(angle);
                y = (i / count) * 8 - 4;
                z = radius * Math.sin(angle);
            }

            targetPositions[i3] = x;
            targetPositions[i3+1] = y;
            targetPositions[i3+2] = z;
        }
    }

    // 核心图像处理
    imgInp.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 128; canvas.height = 128;
                ctx.drawImage(img, 0, 0, 128, 128);
                const data = ctx.getImageData(0, 0, 128, 128).data;
                
                let foundPixels = [];
                for (let y = 0; y < 128; y++) {
                    for (let x = 0; x < 128; x++) {
                        const idx = (y * 128 + x) * 4;
                        if (data[idx] > 30 || data[idx+1] > 30 || data[idx+2] > 30) {
                            foundPixels.push({x: (x - 64) / 15, y: -(y - 64) / 15});
                        }
                    }
                }

                if (foundPixels.length === 0) return;

                shapeMode.value = 'image';
                for (let i = 0; i < currentCount; i++) {
                    const p = foundPixels[i % foundPixels.length];
                    targetPositions[i*3] = p.x + (Math.random() - 0.5) * 0.2;
                    targetPositions[i*3+1] = p.y + (Math.random() - 0.5) * 0.2;
                    targetPositions[i*3+2] = (Math.random() - 0.5) * 0.5;
                }
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    };

    function bindEvents() {
        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        shapeMode.onchange = (e) => updateShapeTarget(e.target.value);
        document.getElementById('pSize').oninput = (e) => {
            points.material.size = parseFloat(e.target.value);
            document.getElementById('val-size').innerText = e.target.value;
        };
        document.getElementById('pSpeed').oninput = (e) => document.getElementById('val-speed').innerText = e.target.value;
        document.getElementById('pNoise').oninput = (e) => document.getElementById('val-noise').innerText = e.target.value;
        document.getElementById('mForce').oninput = (e) => document.getElementById('val-mforce').innerText = e.target.value;
        document.getElementById('pColor').oninput = (e) => points.material.color.set(e.target.value);
        document.getElementById('bgColor').oninput = (e) => renderer.setClearColor(e.target.value);
        document.getElementById('pCount').onchange = () => createSystem();

        // 简单的 3D 旋转交互
        let isDragging = false;
        let prevM = {x:0, y:0};
        window.addEventListener('mousedown', () => isDragging = true);
        window.addEventListener('mouseup', () => isDragging = false);
        window.addEventListener('mousemove', (e) => {
            if(!isDragging) return;
            points.rotation.y += (e.clientX - prevM.x) * 0.01;
            points.rotation.x += (e.clientY - prevM.y) * 0.01;
            prevM = {x: e.clientX, y: e.clientY};
        });
        window.addEventListener('wheel', (e) => {
            camera.position.z += e.deltaY * 0.005;
            camera.position.z = Math.max(1, Math.min(camera.position.z, 20));
        });
    }

    function animate() {
        requestAnimationFrame(animate);
        
        const posArr = points.geometry.attributes.position.array;
        const speed = parseFloat(document.getElementById('pSpeed').value) * 0.05;
        const noise = parseFloat(document.getElementById('pNoise').value) * 0.01;
        const force = parseFloat(document.getElementById('mForce').value);

        for (let i = 0; i < currentCount; i++) {
            const i3 = i * 3;
            
            // 趋向目标位置 (平滑动画)
            posArr[i3] += (targetPositions[i3] - posArr[i3]) * speed;
            posArr[i3+1] += (targetPositions[i3+1] - posArr[i3+1]) * speed;
            posArr[i3+2] += (targetPositions[i3+2] - posArr[i3+2]) * speed;

            // 随机噪点注入
            posArr[i3] += (Math.random() - 0.5) * noise;
            posArr[i3+1] += (Math.random() - 0.5) * noise;

            // 鼠标交互平衡影响
            const mx = mouse.x * 5;
            const my = mouse.y * 5;
            const dx = posArr[i3] - mx;
            const dy = posArr[i3+1] - my;
            const d = Math.sqrt(dx*dx + dy*dy);
            if (d < 2) {
                const repulse = (2 - d) * force * 0.01;
                posArr[i3] += dx * repulse;
                posArr[i3+1] += dy * repulse;
            }
        }

        points.geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }

    function saveFrame(fmt) {
        const data = renderer.domElement.toDataURL(`image/${fmt}`);
        const link = document.createElement('a');
        link.download = `ROVER_EXPORT_${Date.now()}.${fmt}`;
        link.href = data;
        link.click();
    }

    // 启动系统
    window.onload = init;
</script>
</body>
</html>
